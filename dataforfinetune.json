{"databse_question": [
    {
        "id":"alpaca_{0}",
        "instruction":"데이터베이스의 특징에 대해 설명해주세요",
        "input":"",
        "output":"비정형적인 질의에 대해 실시간 처리에 의한 응답이 가능해야하며, 데이터베이스는 항상 최신의 데이터를 유지해야합니다. 데이터베이스는 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야하며, 데이터를 참조할 때 데이터의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾을 수 있어야합니다."
    },
    {
        "id":"alpaca_{1}",
        "instruction":"데이터베이스 언어 DDL, DML, DCL에 대해 설명해주세요",
        "input":"",
        "output":"DDL은 데이터베이스 구조를 정의, 수정, 삭제하는 언어, DML은 데이터베이스내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어, DCL은 데이터에 대해 무결성 유지, 병행 수행 재어, 보호와 관리른 언어입니다."
    },
    {
        "id":"alpaca_{2}",
        "instruction":"트리거에 대해 설명해주세요",
        "input":"",
        "output":"트리거는 특정 테이블에 대한 이벤트에 반응해 DML 문이 수행 되었을 때 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다. 사용자가 직접 호출하는 것이 아니라 데이터베이스가 자동으로 호출한다는 것이 가장 큰 특징입니다."
    },
    {
        "id":"alpaca_{3}",
        "instruction":"Index의 정의와 장단점을 설명해주세요.",
        "input":"",
        "output":"Index란 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법입니다. 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는 것이 빠르다는 장점이 있지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려지는 단점이 있습니다."
    },
    {
        "id":"alpaca_{4}",
        "instruction":"정규화에 대해 설명해주세요",
        "input":"",
        "output":"하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 가지도록하는 방법입니다. 정규화에는 4가지 정규형이 있습니다. 제1 정규형은 테이블의 컬럼이 하나의 값을 갖도록 분해하도록 하는 형태이고, 제2 정규형은 제1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한 형태입니다. 제3 정규형은 제2 정규형을 만족하고, 이행적 함수 종속을 없애도록 분해한 형태입니다. 마지막으로 BCNF 정규형은 제3 정규형을 만족하고, 함수 종속성이 성립할 때 모든 결정자가 후보키가 되도록 분해한 정규형입니다."
    },
    {
        "id":"alpaca_{5}",
        "instruction":"정규화의 장단점을 설명해주세요",
        "input":"",
        "output":"장점으로는 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다는 점과 정규화된 데이터베이스를 구조 확장 할 시에 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다는 점이 있습니다. 단점으로는 릴레이션의 분해로 인해 릴레이션 간의 JOIN연산이 많아지기 때문에 질의에 대한 응답시간이 느려질 수 있다는 점이 있습니다."
    },
    {
        "id":"alpaca_{6}",
        "instruction":"역정규화를 하는 이유를 설명해주세요",
        "input":"",
        "output":"정규화를 거치면 릴레이션 간의 JOIN연산이 많아져 성능이 저하될 우려가 있기 때문에 읽기 작업이 많이 필요한 데이터베이스의 전반적인 성능을 향상시키기 위해 역정규화를 실행합니다. "
    },
    {
        "id":"alpaca_{7}",
        "instruction":"이상 현상의 종류와 각각의 정의를 설명해주세요",
        "input":"",
        "output":"이상 현상은 테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류를 말합니다. 그 종류로는 삽입 이상, 갱신 이상, 삭제 이상이 있습니다. 삽입이상은 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야하는 현상이고, 갱신 이상은 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상입니다. 마지막으로 삭제 이상은 특정 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상을 말합니다."
    },
    {
        "id":"alpaca_{8}",
        "instruction":"SQL INJECTION이 무엇인지 설명해주세요",
        "input":"",
        "output":"SQL INJECTION이란 공격자가 악의적인 의도를 지닌 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법입니다."
    },
    {
        "id":"alpaca_{9}",
        "instruction":"SQL INJECTION을 방어 및 방지하기 위한 방법에 대해 설명해주세요",
        "input":"",
        "output":"입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값인지 검증하는 방법 또는 저장 프로시저를 사용합니다."
    },
    {
        "id":"alpaca_{10}",
        "instruction":"RDBMS와 NoSQL의 차이에 대해 설명해주세요",
        "input":"",
        "output":"RDBMS는 모든 데이터를 2차원 테이블 형태로 표현합니다. 장점으로는 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다는 점이며, 단점으로는 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다는 점이 있습니다. NoSQL은 RDBMS와 달리 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다. 장점으로는 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있고 데이터 분산이 용이하여 성능 향상을 위한 scale-up뿐만 아니라 scale-out 또한 가능하다는 점입니다. 단점으로는 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 모든 컬렉션에서 수정 작업을 수행해야하고, 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다는 점이 있습니다."
    },
    {
        "id":"alpaca_{11}",
        "instruction":"RDBMS와 NoSQL은 어느 경우에 적합한가요?",
        "input":"",
        "output":"RDBMS는 데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우에 사용하는 것이 좋습니다 또한 중복된 데이터가 없어 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다. 반면 NoSQL은 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋습니다. 또한 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 갱신이 많이 이루어지지 않는 시스템에 적합합니다."
    },
    {
        "id":"alpaca_{12}",
        "instruction":"트랜잭션이란 무엇인지 설명해주세요.",
        "input":"",
        "output":"트랜잭션은 작업의 완전성을 보장해줍니다. 작업들이 모두 처리되거나 처리되지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상을 방지해주는 기능입니다. 하나의 트랜잭션은 commit되거나 rollback됩니다."
    },
    {
        "id":"alpaca_{13}",
        "instruction":"트랜잭션의 특성에 대해 설명해주세요",
        "input":"",
        "output":"작업이 모두 반영되던지 아니면 하나도 반영되지 않아야한다는 원자성, 실행이 완료되면 언제나 일관성 있는 상태를 유지해야한다는 일관성, 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다는 독립성, 완료된 결과는 영구적으로 반영되어야한다는 영구성 4가지가 있습니다."
    },
    {
        "id":"alpaca_{14}",
        "instruction":"데이터베이스 락에 대해 설명해주세요",
        "input":"",
        "output":"데이터베이스 락은 트랜잭션 처리의 순차성을 보장하기 위한 방법입니다. 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락 끼리는 동시에 접근이 가능합니다. 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다."
    },
    {
        "id":"alpaca_{15}",
        "instruction":"Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요",
        "input":"",
        "output":"RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다. 하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능합니다."
    },
    {
        "id":"alpaca_{16}",
        "instruction":"옵티마이저에 대해 설명해주세요",
        "input":"",
        "output":"옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저에서 해당 SQL을 처리할 여러 방법을 만들고 그중 최적의 효율을 갖는 방법을 택해 SQL을 수행하게됩니다."
    },
    {
        "id":"alpaca_{17}",
        "instruction":"inner join과 outer join의 차이를 설명해주세요",
        "input":"",
        "output":"inner join은 서로 연관된 내용만 검색하는 join방법이고, outer join은 한쪽에만 데이터가 존재하는 경우 데이터가 존재하는 쪽의 내용을 전부 출력하는 방법입니다. 벤다이어그램으로 봤을 때 inner join은 교집합, outer join은 합집합에 대응됩니다."
    },
    {
        "id":"alpaca_{18}",
        "instruction":"group by의 역할에 대해 설명해주세요",
        "input":"",
        "output":"group by는 group by 명령어를 통해 특정 칼럼을 기준으로 연산한 결과를 집계 키로 정의하여 그룹을 짓는 역할을 합니다. 집합 연산자는 COUNT, SUM , AVG, MAX, MIN 등이 있고, DISTINCT와 같이 중복 데이터를 제거하는 특징이 있습니다."
    },
    {
        "id":"alpaca_{19}",
        "instruction":"DELETE, TRUNCATE, DROP의 차이를 설명해주세요",
        "input":"",
        "output":"DELETE는 데이터는 지우지만 테이블 크기는 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. 삭제 후 복원이 가능합니다. TRUNCATE는 전체 데이터를 한번에 삭제하는 방식입니다. 테이블 크기가 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고, 삭제 후 복원이 불가능합니다. DROP은 테이블 자체를 완전히 삭제하는 방법입니다. 삭제 후 복원이 불가능합니다."
    },
    {
        "id":"alpaca_{20}",
        "instruction":"JOIN에서 ON과 WHERE의 차이를 설명해주세요",
        "input":"",
        "output":"ON이 WHERE보다 먼저 실행되어 JOIN을 하기 전에 필터링을 하고 WHERE은 JOIN을 한 후에 필터링을 합니다."
    }
],
"java_question":[
    {
        "id":"alpaca_{0}",
        "instruction":"Java의 특징을 설명해주세요",
        "input":"",
        "output":"Java는 객체지향 프로그래밍 언어입니다. 기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어입니다. Java의 장점은 Java로 작성된 코드는 JVM위에서 실행하기 때문에 운영체제에 대해 독립적이며, Garbage Collector를 통해 메모리가 자동적으로 관리된다는 점이 있습니다. 단점으로는 JVM위에서 코드가 동작되기 때문에 상대적으로 실행속도가 느리다는 점과, 다중 상속이나 타입에 엄격하며, 제약이 많다는 점이 있습니다."
    },
    {
        "id":"alpaca_{1}",
        "instruction":"JVM의 역할에 대해 설명해주세요",
        "input":"",
        "output":"JVM은 스택 기반으로 동작하며 Java Byte Code를 OS에 맞게 해석해주는 역할을 하고 가비지컬렉션을 통해 자동으로 메모리를 관리해줍니다."
    },
    {
        "id":"alpaca_{2}",
        "instruction":"Java의 컴파일 과정에 대해 설명해주세요",
        "input":"",
        "output":"1. 개발자가 java파일을 생성한다. 2. build한다. 3. Java compiler의 javac 명령어를 통해 바이트코드를 생성한다. 4. class loader를 통해 JVM 메모리 내로 로드한다. 5. 실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석한다. 의 순을 가집니다."
    },
    {
        "id":"alpaca_{3}",
        "instruction":"Java에서 제공하는 원시타입들에는 무엇이 있고, 각각 몇 바이트를 차지하나요?",
        "input":"",
        "output":"정수형 byte, short, int, long, 실수형 float, double, 문자형 char, 논리형 boolean이 있고, 순서대로 정수형 1, 2, 4, 8, 실수형, 4, 8, 문자형 2, 논리형 1 바이트를 차지합니다."
    },
    {
        "id":"alpaca_{4}",
        "instruction":"오버라이딩과 오버로딩에 대해 설명해주세요",
        "input":"",
        "output":"오버라이딩은 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것이고, 오버로딩은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말합니다."
    },
    {
        "id":"alpaca_{5}",
        "instruction":"객체지향 프로그래밍에 대해 설명해주세요",
        "input":"",
        "output":"우리가 실생활에서 쓰는 모든 것을 객체라 하며, 객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 상태와 행위를 가진 객체를 만들어 각각의 객체들의 역할을 정의하고 객체들간의 상호작용을 통해 수행되는 프로그램을 작성하는 개발방법입니다. 즉 기능이 아닌 객체가 중심이며 어떤 객체가 어떤 일을 할것인가가 핵심개념입니다."
    },
    {
        "id":"alpaca_{6}",
        "instruction":"추상 클래스와 인터페이스를 설명하고, 그 차이점을 설명해주세요",
        "input":"",
        "output":"추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고, 인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다. 차이점으로는 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정 메소드가 반드시 존재하도록 강제함에 있고, 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다는 점입니다. 그리고 추상클래스는 다중 상속이 불가능하지만, 인터페이스는 다중상속이 가능하다는 점이 다릅니다."
    },
    {
        "id":"alpaca_{7}",
        "instruction":"싱글톤 패턴에 대해 설명해주세요",
        "input":"",
        "output":"싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다. 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와 동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용합니다."
    },
    {
        "id":"alpaca_{8}",
        "instruction":"가비지 컬렉션에 대해 설명해주세요",
        "input":"",
        "output":"가비지 컬렉션은 JVM의 메모리 관리 기법중 하나로 시스템에서 동적으로 할당됐던 메모리 영역중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법입니다."
    },
    {
        "id":"alpaca_{9}",
        "instruction":"클래스와 객체에 대해 설명해주세요",
        "input":"",
        "output":"클래스는 객체를 만들어내기 위한 설계도 혹은 틀이라고 할 수 있고, 객체를 생성하는데 사용합니다. 객체는 클래스를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다. 여기서 상태는 필드, 행동은 메소드라고 표현합니다. 객체에 메모리가 할당되어 실제로 활용되는 객체는 인스턴스라고 부릅니다."
    },
    {
        "id":"alpaca_{10}",
        "instruction":"생성자에 대해 설명해주세요",
        "input":"",
        "output":"생성자는 클래스와 같은 이름의 메소드로, 객체가 생성될 때 호출되는 메소드입니다. 명시적으로 생성자를 만들지 않아도 default생성자가 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있습니다."
    },
    {
        "id":"alpaca_{11}",
        "instruction":"Wrapper Class란 무엇이며, Boxing과 Unboxing은 무엇인지 설명해주세요",
        "input":"",
        "output":"기본 자료형에 대한 객체 표현을 Wrapper class라고 합니다. 기본 자료형을 Wrapper class로 변환하는 것을 Boxing이라고 하며, Wrapper class를 기본 자료형으로 변환하는 것을 Unboxing이라고 합니다."
    },
    {
        "id":"alpaca_{12}",
        "instruction":"Synchronized에 대해 설명해주세요",
        "input":"",
        "output":"여러개의 스레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 스레드를 제외하고 나머지 스레드들은 데이터에 접근할 수 없게 막는 키워드입니다. 멀티 스레드 환경에서 스레드간 동기화를 시켜 데이터의 thread-safe를 보장해줍니다."
    },
    {
        "id":"alpaca_{13}",
        "instruction":"new String()과 리터럴의 차이에 대해 설명해주세요",
        "input":"",
        "output":"new String()은 new 키워드로 새로운 객체를 생성하기에 Heap메모리 영역에 저장되고, 리터럴은 Heap안에 있는 String Conastant Pool에 저장됩니다."
    },
    {
        "id":"alpaca_{14}",
        "instruction":"접근 제한자에 대해 설명해주세요",
        "input":"",
        "output":"변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미하고 총 4가지 종류가 있습니다. 1. public - 접근 제한이 없다. 2. protected - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능하다. 3. default - 해당 패키지에서만 접근 가능하다. 4. private - 해당 클래스에서만 접근가능하다."
    },
    {
        "id":"alpaca_{15}",
        "instruction":"클래스 멤버 변수 초기화 순서에 대해 설명해주세요",
        "input":"",
        "output":"1. static 변수 선언부 2. 필드 변수 선언부 3. 생성자 block"
    },
    {
        "id":"alpaca_{16}",
        "instruction":"static에 대해 설명해주세요",
        "input":"",
        "output":"static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 로드될 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있습니다. 모든 객체가 메모리를 공유한다는 특징이 있고, Garbage Collection 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재하게 됩니다."
    },
    {
        "id":"alpaca_{17}",
        "instruction":"내부 클래스의 장점에 대해 설명해주세요",
        "input":"",
        "output":"내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있고, 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있습니다."
    },
    {
        "id":"alpaca_{18}",
        "instruction":"리플렉션이 무엇인지 설명해주세요",
        "input":"",
        "output":"리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API입니다."
    },
    {
        "id":"alpaca_{19}",
        "instruction":"Vector와 List의 차이를 설명해주세요",
        "input":"",
        "output":"벡터는 데이터 삽입 시 앞 부분에 삽입하고, 리스트는 뒷 부분에 삽입하기 때문에 삽입 삭제 부분에서 리스트가 시간복잡도의 우위를 가집니다. 벡터는 랜덤 부분 접근이 가능하지만, 리스트는 순차 접근만 가능하기 때문에 검색 부분에서는 벡터가 우위를 지닙니다."
    },
    {
        "id":"alpaca_{idx}",
        "instruction":"",
        "input":"",
        "output":""
    }
]}